# Task 2 â€“ Graphical and Structural Data

## Goals

There are the following goals for this task: learn how to

1. create a reactive and interactive user interface using graphical data
2. create an application using a layered design pattern (layered architecture)
3. implement bidirectional communication based on unidirectional dependencies between layers
4. interact with external structured data stored in databases using Language Integrated Query (LINQ) in a programming language
5. preselect business process data by the database management system

## Description of the task

Students are required to develop a computer program using a multi-layer design pattern. The program should feature a Graphical User Interface (GUI), an object model interconnected with a relational database. The object model created earlier must be reused. Specifically, the following requirements must be met.

- create applications for the Windows operating system in `WPF` technology
- Implement multi-layer applications containing presentation, logic, and data layers as follows:
  - **Data**: responsible for access to the external data repository
  - **Logic**: responsible for implementation of the primary business logic algorithm
  - **Presentation**: responsible for the implementation of the graphical user interface (GUI)
- to implement the presentation layer, the `MVVM` design pattern must be used. The `Architecture` section provides implementation details
- the connection between the in-process object model and the relational database must be implemented using LINQ technology
- the unit tests should be developed for each part of the project independently

## Architecture

### Data layer

- the business process data is preserved in an SQL database
- the temporal business data is gathered in-process object model
- it needs an interconnection between the database and the in-process object model using the LINQ to SQL technology
- query syntax and method syntax must be simultaneously used to implement this interconnection
- only this layer is directly interconnected to the database
- consider an implementation of the in-process object model based on the attached UML class diagram
- it is suggested that this layer be implemented as a separate project in the solution - this way, unit tests can be implemented only for this layer, separating the concerns

### Logic layer

- this layer is a set of types responsible for the implementation of an algorithm dedicated to processing business data
- during the implementation of services (algorithm) it is necessary to provide functionality that allows indirectly create, read, update, and delete the entities (in short `CRUD`) from the database
- it is suggested that this layer be implemented as a separate project in the solution - this way, unit tests can be implemented only for this layer, separating the concerns

### Presentation layer

To utilize the graphical data, a `Visual C#  WPF Application` must be created, i.e., an application for Windows that is based on the Windows Presentation Foundation (WPF) technology. A key work in this statement is presentation. Create the main application window and define its basic behavior, such as initialization and shutdown. Design the appropriate GUI using `XAML` language. Use the logic layer to manipulate business process data.

The presentation layer must be implemented in accordance with the Model-View-ViewModel (MVVM) design pattern. MVVM is a layered design pattern, which means the presentation layer is composed of the following sub-layers:

- `View`: contains a set of controls that directly provide interaction between a user and a program, designed using the `XAML` Domain Specific Language (DSL). This sub-layer should be implemented in a dedicated project, which is the only one allowed to reference the WPF framework, because this framework is not portable; its scope of use must be limited
- `ViewModel`: Contains types responsible for the proper behavior of the user interface, which should be designed to display current data and execute user commands based on the state of the interface. This layer must not depend directly on the `WPF` framework. It acts as a bridge between the `View` and the underlying `Model` layer
- `Model`: types responsible for storing data required by the graphical user interface (GUI) and for performing data operations through the interface provided by the logic layer

It is suggested that this layer be implemented as three separate projects, with the Model sub-layer having a dependency only on the Logic layer project. This way, unit tests can be implemented, separating the concerns.

The data and controls should be bound using a data binding mechanism. This also means that you should avoid writing C# code in the `View` layer (i.e., code-behind in *.xaml.cs files), except for code automatically generated by the development environment. To notify the View layer about changes in the underlying layers, use events and custom delegates.

To handle user commands, the command mechanism (i.e., implementation of the `ICommand` interface) should be used. This applies particularly to buttons, but also to menus and other UI elements. Commands should be implemented as independent classes within the `ViewModel` layer.

The GUI should be designed to display a list of main elements with basic information, while showing independently detailed information for the selected element. This design pattern is known as the Master-Detail View Pattern.

The GUI should be designed to display a list of main elements with basic information. Detailed information should be shown for the selected element. This requires implementing the Master-Detail pattern. In the Master view, data should be presented in a tabular format without detailed information, which should be reserved for the Detail view. To display individual element data, the DataTemplate pattern should be used.

The interface should not only display business process data but also allow editing at every level. For example, when managing employee data, the application should support adding and removing employees, as well as editing individual employee details. It must also enable saving new or modified data to the database. In the user interface, data-saving operations should be accessible via a dedicated button or through the menu. In short, the interface must be both reactive and interactive.

## Guidelines for implementation

Implementing the presented requirements requires the application of good software development practices. More information on this topic can be found in the "See also" section.

Database operations, as potentially time-consuming, should not be executed in a way that would block a GUI, which could cause a lack of application responsiveness. Hence, it is recommended to use asynchronous command execution, for example, by using the `Task` class (i.e., *Task-based Asynchronous Pattern* for read and write operations in the database. The following example shows how this problem can be solved.

// Operation outside the user interface

``` C#
void LongOperation() {
  // ...
}
```

``` C#
// Implementation of ICommand
void Execute() {
  // wrong
  LongOperation();

  // correct
  Task.Run(() => {LongOperation();}
 );
}
```

Many libraries support the implementation of the MVVM pattern. When considering using one of them, keep in mind that the main goal of this task is to understand what the MVVM mechanism is used for and how it works. This principle applies regardless of the chosen solution. Implementing the solution yourself, rather than relying on an existing library, makes it much easier to answer relevant questions and explain this design pattern.

In this task, it is not required, but while GUI implementation, it is often necessary to display an additional window (commonly referred to as a pop-up) to notify the user of an error or a situation requiring a decision. It is recommended to use the dependency injection pattern for this purpose. Importantly, only the view layer is permitted to use the WPF framework. In other words, **the ViewModel layer must not directly display any user controls**.

## See Also

### Main references

- [GitHub mpostol/TP](https://github.com/mpostol/TP)- C# in Practice - set of C# examples targeting education purpose
- [Programming in Practice; GitBook eBook](https://mpostol.gitbook.io/pip/) - The content of this eBook is auto-generated using the Markdown files collected in this repository. It is distributed online under the open access rules.

### Introduction

- [Windows Presentation Foundation](http://msdn.microsoft.com/library/ms754130.aspx)
- [WPF architecture](http://msdn.microsoft.com/library/ms750441.aspx)
- [XAML language](http://msdn.microsoft.com/library/ms747122.aspx)
- [WPF data binding](http://msdn.microsoft.com/library/ms752347.aspx)
- [Windows 10 MVVM In Depth](https://channel9.msdn.com/events/DEVintersection/DEVintersection-2016/DEV12)

### Realization of the task

- [MVVM TUTORIAL FROM START TO FINISH](http://www.software-architects.com/devblog/2010/09/10/MVVM-Tutorial-from-Start-to-Finish)
- [WPF Master Details MVVM Application](http://www.codeproject.com/Articles/332615/WPF-Master-Details-MVVM-Application)
- [Opis relacji bazy danych Adventure Works](https://akela.mendelu.cz/~jprich/vyuka/db2/AdventureWorks2008_db_diagram.pdf)

### Additional resources

- [Optimizing WPF Application Performance](http://msdn.microsoft.com/library/aa970683.aspx)
- [Implementing the MVVM Pattern Using the Prism Library 5.0 for WPF](http://msdn.microsoft.com/library/gg405484.aspx)
- [MVVM Best Practices](https://channel9.msdn.com/Shows/Visual-Studio-Toolbox/MVVM-Best-Practices)
- [A Practical Quick-start Tutorial on MVVM in WPF](http://www.codeproject.com/Articles/81484/A-Practical-Quick-start-Tutorial-on-MVVM-in-WPF)
- [Asynchronous programming patterns](https://msdn.microsoft.com/library/jj152938.aspx)
- [Task-based Asynchronous Pattern (TAP)](https://msdn.microsoft.com/library/hh873175.aspx)
