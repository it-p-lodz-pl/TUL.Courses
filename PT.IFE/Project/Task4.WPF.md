
# Task 4 – WPF

## Aims
The goal of the task is to learn how to create applications for Windows operating system with aid of `WPF` technology, `XAML` language and according to the `MVVM` software architectural pattern. After finishing the task student will be able to:

- Create applications for Windows operating system in `WPF` technology,
- Define the user interface with use of `XAML` language,
- Use the `MVVM` software architecture,
- Implement multi-layer applications.

## Description of the task

As a part of the task the student should create the computer application with multi-layer architecture designed to edit data using a graphical user interface. The task should be implemented using the data layer implemented previously in task 1. 

The unit tests should be developed for each part of the project.

The following layers should be clearly identified (they are described in detail in the `Architecture` section):

- **Data layer**: access to the data repository
- **Services**: data processing services
- **Presentation**: graphical user interface (GUI)

## Architecture

### Data layer

As the process data repository the SQL database should be used and the types responsible for interaction with this database should be defined using LINQ to SQL. Where necessary, the functionality offered by these types should be extended.

### Services layer

- Classes responsible for processing of the data stored in the database must be implemented as a separate layer
- During the implementation of services it is necessary to provide functionality that allows to create, read, update and delete the entities (in short `CRUD`) from the database
- This layer should also provide the public API and hide the details of the implementation, e.g. the need to create a <code>DataContext</code>
- This layer must be implemented as a separate project

### Presentation layer

One should create a new `Visual C # > WPF Application`, i.e. an application for Windows using `WPF` technology that allows you to view and edit data. Create the main application window and define its basic behavior, such as initialization and shutdown. Design the appropriate GUI using `XAML` language. Use the created data service to manipulate data.

This layer must be implemented in accordance with the `Model-View-ViewModel` (`MVVM`) software pattern. This means that the following layers should be separated in it:

- View: a set of controls that directly provide interaction between a user and a program designed using `XAML` (`* .xaml`).
- `ViewModel`: classes responsible for the proper behavior of the user interface which should be designed to display current data and execute user commands depending on the state of the interface. The layer responsible for linking the controls to the API offered by the <code>Model</code> layer.
- <code>Model</code>: classes responsible for the storage of data required by the user interface (GUI) and needed for realization of data operations with use of the functionality offered by the layer described in the previous section Service layer.

The data and controls must be bind together using the <code>DataBinding</code> data binding mechanism. It also means that you should not create a C# code in the view layer (so called code-behind) in <code>* .xaml.cs</code> files, except for the code automatically generated by <code>Visual Studio</code>. In order to notify the <code>View</code> layer about changes in the lower layer, the implementation of <code>INotifyPropertyChanged</code> and <code>INotifyCollectionChanged</code> interfaces or their derivatives should be used.

In order to handle user commands the command mechanism (implementation of the <code>ICommand</code> interface) should be used. This applies in particular to the operation of buttons, but also to menus and other interface elements. The commands should be implemented as independent classes in the <code>ViewModel</code> layer.

The GUI should be designed in a way allowing to display a list of the main elements with the basic information. The detailed information should be presented for the selected element.

This means the need of implementation of the <code>Master-Detail</code> pattern. In the <code>Master</code> view, one should display data in the form of a table, without providing detailed information about the elements, which should be included only in the <code>Detail</code> view. The <code>DataTemplate</code> pattern elements should be used to display the data of individual elements.

The interface besides displaying the data must allow for its editing at any level. For example when editing employees' data, the program should enable adding and removing employees, as well as editing the data of a specific employee. The program must allow for the storage of new or modified data in the database. In the user interface, it should be possible to perform data storage operations with a separate button or using the menu.

Guidelines for implementation 
The implementation of the task should take into account the recommendations defined by the programmers of Microsoft (Patterns & Practices), as well as good software development practices. More information on this subject can be found in the Suplementary materials section. In particular it should:
- Keep transparency of code implementation and segregation, i.a. by using the <code>Models</code>, <code>Views</code> and <code>ViewModels</code> folders.
- Take advantage of good programming practices such as  <code>SOLID</code>, <code>DRY</code> and others.

It is also necessary to take care of constraints resulting from the structure of the database, e.g. the length of text fields. This means that data needs to be validated. Validation should take advantage of <code>IDataErrorInfo</code>, <code>INotifyDataErrorInfo</code> interfaces or create a mapping from <code>Validation Rule</code> that would check the data before sending it to the database.

Database operations, as potentially time-consuming, should not be executed in a way that would block a GUI which could cause a lack of interaction with the user. Hence, it is recommended to use asynchronous command execution, for example by using the <code>Task</code> class (i.e. <code>Task-based Asynchronous Pattern</code>) for read and write operations in the database. The following example shows how this problem can be solved. 

// Operation outside the user interface 
void LongOperation() {
  // ...
}

// Implementation of ICommand
void Execute() {
  // zle
  LongOperation();

  // dobrze
  Task.Run(() => {
    LongOperation();
  });
}
There exist a lot of libraries that suppor the use of the MVVM pattern. Considering the use of one of them, please take into account that the main goal of the task is to understand what this mechanism is used for and how it works. This rule applies regardless of the proposed solution. It is clear that when implementing the chosen solutions by yourself it is guaranteed that the answer to the above questions is much easier.

It is often required during the implementation of GUI to show the user an additional window in order to signal an error or a situation that requires his/her decision. There are many ways to solve this problem. In this task, it is recommended to perform this type of operation in the <code>ViewModel</code> layer. Unfortunately, this makes it difficult to test this layer, because in a unit test a graphical control may appear, which is contradictory to the principle that tests must be carried out without interaction with the user. To solve this problem, simply use the dependency injection pattern and replace this functionality with another one that does not use graphical controls.

Suplementary materials

Introduction
Windows Presentation Foundation
WPF architecture
XAML language
WPF data binding
Introduction to the MVVM pattern
Universal applications with MVVM 

Realization of the task
A long MVVM course
Example of data editing application in WPF with MVVM
Description of the Adventure Works database

Additional resources
Optimization of WPF applications
Implementation of the MVVM pattern in WPF with the Prism library
Creating applications for Windows 8
Best practices of MVVM
A short MVVM course
Asynchronous programming
Pattern of asynchronous tasks 

# Task 4 - WPF

# Cel

Celem zadania jest poznanie sposobu tworzenia aplikacji dla systemu Windows w oparciu o technologię `WPF` i język `XAML` z wykorzystaniem wzorca `MVVM`. Po zakończeniu zadania student będzie potrafił:

- Tworzyć aplikacje dla systemu Windows w technologii `WPF`,
- Definiować interfejs użytkownika z wykorzystaniem języka `XAML`,
- Stosować architekturę `MVVM`,
- Realizować aplikacje wielowarstwowe.

# Opis zadania

## Wstęp ##

Zadanie polega na opracowaniu programu komputerowego o architekturze wielowarstwowej przeznaczonego do edycji danych z wykorzystaniem graficznego interfejsu użytkownika. Powinno być zrealizowane z wykorzystaniem warstwy danych zrealizowanej w zadaniu 3. 

Do każdej części projektu powinny zostać opracowane testy jednostkowe.

Należy wyraźnie wydzielić następujące warstwy, które opisano w rozdziale **Architektura**:

- **Danych**: dostęp do repozytorium danych 
- **Usług**: usług przetwarzania danych
- **GUI**: graficznego interfejsu użytkownika

## Architektura

### Warstwa danych
 
Podobnie jak w zadaniu 3 należy wykorzystać jako repozytorium danych procesowych bazę SQL `AdventureWorks` i utworzone w tym zadaniu typy odpowiedzialne za interakcję z tą bazą. W miarę potrzeb funkcjonalność oferowana przez te typy powinna być rozszerzona.  W uzasadnionych przypadkach dopuszcza się możliwość modyfikowania uprzednio opracowanego kodu źródłowego.

### Warstwa usług 

- Klasy odpowiedzialne za przetwarzanie danych procesowych zgromadzonych w bazie muszą być zaimplementowane jako osobna warstwa,
- Usługi powinien przypominać zastosowany w zadaniu 1 klasę `DataRepository`,
- Realizując usługi należy dostarczyć funkcjonalność umożliwiającą tworzenie, odczyt, aktualizację i usuwania encji (w skrócie oznaczanych `CRUD`) z bazy danych,
- Ta warstwa powinien udostępniać publiczne API, a ukrywać szczegóły implementacji, np. potrzebę tworzenia `DataContext`,
- Warstwa musi być zrealizowana jako osobny projekt.

### Graficzny interfejs użytkownika (GUI)

Należy utworzyć nowy projekt `Visual C# > WPF Application`, czyli aplikację dla systemu Windows z wykorzystaniem technologii `WPF` pozwalającą na przeglądanie i edycję danych.
- Utworzyć okno główne aplikacji i zdefiniować jej podstawowe zachowania, jak inicjalizacja i wyłączenie,
- Zaprojektować odpowiedni interfejs graficzny GUI wykorzystując język XAML,
- Wykorzystać utworzony serwis danych do operowania na danych.

Warstwa ta musi być zaimplementowany zgodnie ze wzorcem `Model-View-ViewModel` (`MVVM`). Oznacza to, że należy w niej wydzielić następujące warstwy:

- `View`: zestaw kontrolek bezpośrednio zapewniający interakcję pomiędzy użytkownikiem i programem zaprojektowany z wykorzystaniem języka XAML (`*.xaml`).
- `ViewModel`: klasy odpowiedzialne za odpowiednie zachowanie się interfejsu użytkownika tak, aby wyświetlać aktualne dane i realizować polecenia użytkownika w zależności od stanu interfejsu. Warstwa odpowiedzialna za powiązanie kontrolek z API oferowanym przez warstwę `Model`   
- `Model`: klasy odpowiedzialne za przechowywanie danych na potrzeby interfejsu użytkownika (GUI) i realizację operacji na danych z wykorzystaniem funkcjonalności oferowanej przez warstwę opisaną w poprzednim rozdziale **Warstwa usług**,

Dane i kontrolki muszą być powiązane ze sobą za pomocą mechanizmu wiązania danych `DataBinding`. Oznacza to również, że nie powinno się tworzyć kodu c# w warstwie widoku (tzw. code-behind) w plikach `*.xaml.cs`, poza kodem automatycznie generowanym przez `Visual Studio`. Do powiadamiania warstwy `View` o zmianach zachodzących na niższej warstwie należy wykorzystać implementację interfejsów `INotifyPropertyChanged` oraz `INotifyCollectionChanged` lub ich pochodnych.

Do obsługi poleceń użytkownika należy wykorzystać mechanizm poleceń (implementacja interfejsu `ICommand`). Dotyczy to w szczególności obsługi przycisków, ale także menu i innych elementów interfejsu. Polecenia powinny zostać zaimplementowane jako niezależne klasy w warstwie `ViewModel`.

GUI należy zaprojektować tak, aby wyświetlać listę głównych elementów z podstawową informacją. Dla zaznaczonego elementu powinny zostać zaprezentowane dane szczegółowe. Oznacza to implementację wzorca `Master-Detail`. Na widoku `Master` należy wyświetlić dane w formie tabeli, bez zawierania dokładnych informacji o elementach, które powinny być zawarte dopiero na widoku szczegółowym `Detail`. Do wyświetlenia danych poszczególnych elementów należy użyć elementy wzorców `DataTemplate`.

Interfejs poza wyświetlaniem musi pozwolić na edycję danych, na dowolnym poziomie. Edytując dane pracowników, program powinien umożliwić dodawanie i usuwanie pracownika, a także edycję danych konkretnego pracownika.
Program musi pozwolić na zapis nowych lub zmodyfikowanych danych do bazy danych. W interfejsie użytkownika powinna istnieć możliwość wykonania operacji zapisu danych osobnym przyciskiem lub za z wykorzystaniem menu.

# Wytyczne do realizacji

Realizacja zadania powinno uwzględniać zalecenia zdefiniowane przez programistów firmy Microsoft (Patterns & Practices), a także dobre praktyki tworzenia oprogramowania. Więcej informacji na ten temat w punkcie **Lista źródeł**, a w szczególności:

* Zachować przejrzystość implementacji i segregacji kodu, m.in. przez stosowanie folderów `Models`, `Views` oraz `ViewModels`.
* Korzystać z dobrych praktyk tworzenia oprogramowania `SOLID`, `DRY` i innych,

Należy również zadbać o ograniczenia wynikające ze struktury w bazie danych, np. długości pól tekstowych.
Oznacza to konieczność walidacji danych. Walidacja powinna wykorzystywać interfejsy `IDataErrorInfo`, `INotifyDataErrorInfo` lub stworzenie mapowania z `Validation Rule`, które zapewnią sprawdzenie danych przed wysłaniem ich do bazy danych.

Operacje bazodanowe jako potencjalnie czasochłonne nie powinny być wykonywane w sposób, który blokowałby GUI objawiający się brakiem interakcji z użytkownikiem. Zaleca się wykorzystanie asynchonicznego wykonania komend, przykładowo wykorzystując klasę `Task` (`Task-based Asynchronous Pattern`) do operacji związanych z odczytem i zapisem w bazie danych. Poniższy przykład pokazuje jak można ten problem rozwiązać.

```
// opreracja poza interfejsem użytkownika
void LongOperation() {
  // ...
}

//Implementacja ICommand
void Execute() {
  // zle
  LongOperation();

  // dobrze
  Task.Run(() => {
    LongOperation();
  });
}

```

Istnieje wiele bibliotek wspierających wykorzystanie wzorca MVVM. Rozważając wykorzystanie jednej z nich proszę brać pod uwagę, że nadrzędnym celem zadania jest zrozumienie po co ten mechanizm jest i jak on działa. Zasada ta będzie egzekwowana bez względu na zaproponowane rozwiązanie. Z doświadczenia wiemy, że implementują wybrane rozwiązania samemu ma się gwarancję, że odpowiedź na powyższe pytania jest zdecydowanie łatwiejsza.

Często realizacja GUI wymaga wyświetlenia użytkownikowi dodatkowego okienka w celu zasygnalizowania sytuacji wymagającej podjęcia decyzji lub wystąpienia błędu. Jest wiele sposobów rozwiązania tego problemu. Dla potrzeb tego zadania zaleca się realizację tego typu operacji w warstwie `ViewModel`. Niestety to utrudnia testowanie tej warstwy, ponieważ w testach jednostkowych może pojawić się graficzna kontrolka, a to jest sprzeczne z zasadą, że testy muszą być realizowane zawsze bez interakcji z użytkownikiem. Aby rozwiązać ten problem wystarczy zastosować wzorzec wstrzykiwania zależności i zastąpić tą funkcjonalność inną, która nie wykorzystuje kontrolek graficznych.


## Lista źródeł

## Wprowadzenie

[Windows Presentation Foundation](http://msdn.microsoft.com/en-us/library/ms754130.aspx)

[Architektura WPF](http://msdn.microsoft.com/en-us/library/ms750441.aspx)

[Język XAML](http://msdn.microsoft.com/en-us/library/ms747122.aspx)

[Wiązanie danych WPF](http://msdn.microsoft.com/en-us/library/ms752347.aspx)

[Wprowadzenie do wzorca MVVM](http://msdn.microsoft.com/pl-pl/library/wprowadzenie-do-wzorca-projektowego-model-view-viewmodel-na-przykladzie-aplikacji-wpf.aspx)

[Uniwersalne aplikacje z MVVM](https://channel9.msdn.com/events/DEVintersection/DEVintersection-2016/DEV12)

## Realizacja zadania

[Długi kurs MVVM](http://www.software-architects.com/devblog/2010/09/10/MVVM-Tutorial-from-Start-to-Finish)

[Przykład aplikacji do edycji danych w WPF z MVVM](http://www.codeproject.com/Articles/332615/WPF-Master-Details-MVVM-Application)

[Opis relacji bazy danych Adventure Works](https://akela.mendelu.cz/~jprich/vyuka/db2/AdventureWorks2008_db_diagram.pdf)

## Dodatkowe

[Optymalizacja aplikacji WPF](http://msdn.microsoft.com/en-us/library/aa970683.aspx)

[Implementacja wzorca MVVM w WPF z biblioteką Prism](http://msdn.microsoft.com/en-us/library/gg405484.aspx)

[Tworzenie aplikacji dla systemu Windows 8](http://channel9.msdn.com/Series/Tworzenie-aplikacji-w-stylu-Modern-UI-dla-programist-w/MVVM-Tworzenie-aplikacji-dla-systemu-Windows-8-dla-programistw)

[Najlepsze praktyki MVVM](https://channel9.msdn.com/Shows/Visual-Studio-Toolbox/MVVM-Best-Practices)

[Krótki kurs MVVM](http://www.codeproject.com/Articles/81484/A-Practical-Quick-start-Tutorial-on-MVVM-in-WPF)

[Programowanie asynchorniczne](https://msdn.microsoft.com/en-us/library/jj152938.aspx)

[Wzorzec zadań asynchornicznych](https://msdn.microsoft.com/en-us/library/hh873175.aspx)

